## 浏览器计时节流

### 需求

如果长时间不对页面进行编辑，自动退出编辑状态。

### 思考过程

1. 最开始是放在了和后端沟通上，为了保证当前时间只能有唯一用户进行编辑，对当前笔记用户还采用了心跳检测。防止多个用户产生同时编辑的情况。
   **setInterval 轮询**

[//]: # (实时行要求不高，和后端沟通费时)

### 实现过程

1. 刚开始是使用 setInterval 进行计时, 功能这些都没问题，但是测试的时候偶然发现时间不是太准确而且非常夸张

**最后发现问题发生在 当前页面在失活的情况下**。
`是因为现代浏览器都是多标签页的情况，为了大量多标签页出现，严重影响电量和电池的续航水岸。专门处理了相关代码，减少后台工作，而后台运行的计时器就是这种优化的一个手段`

> **对于非活动选项卡,会自动限制计时器每 1s 运行一次，而不管代码中的延迟时间。而且随着时间的推移，时间也会慢慢拉大。然而一旦重新激活就会恢复到原始值**

### 解决方式

- 使用 web worker API，将计时器放到另外的线程中。 **通过主线程与 web worker**线程进行通信，发消息来维持 webWorker
  线程中计时器的开关

> (深度思考) 但是这样处理，对于开发其实是有心智负担的，我们的目的仅仅是通过计时器做计时。但是为了解决标签页失活的问题，不得不放在
> webWorker 中，而计时器的开关，还得通过发送开关消息通信来处理

> 所以对 web worker 线程进行了封装，通过动态生成 web worker 脚本，在主线程劫持模拟
> setTimeout、setInterval线程监听主线程发送的消息，并执行对应的计时器，然后在主线程监听消息，并作出对应处理，并发布到公司的公共库
>
>
>

## 动态 web worker 脚本具体做法

利用了 `URL.createObjectURL(blob)`

创建一个 blob 对象，然后**在主线程模拟 `setTimeout`、`setInterval`，内部改成 worker.postMessage 给web worker
线程发送数据,并通过对象缓存计时器的回掉函数和timer参数**，所以发送给 web worker 线程的数据其实就是一个唯一ID

在 web worker 线程中监听主线程发送的消息,并执行相应计时器，同时发回消息给主线程

主线程通过接受信息，从缓存中找到回掉函数，并执行

## 如何判断当前页面是否激活

通过 page visibility API 在 document 上添加时间监听 'visibilitychange'

## setInterval/setTimeout 计时不准确

它们的线程是属于宏任务，它的回掉会受到事件循环、浏览器渲染等影响

浏览器的渲染画面是一帧一帧画出来的，一秒钟绘画60次也就是60帧。

而它们的回掉函数并不是时间到了就立即执行，而是等浏览器空闲后才会执行

当然有用浏览器的计时不准确，就会造成空帧造成卡顿的感觉

### 最后结果
