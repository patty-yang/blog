## Vue3 对比 Vue2 有什么变化

我觉得可以分为大概四类

1. `源码层面的优化`
2. `性能方面的优化`
3. `API 语法方面的优化`
4. `引入了 RFC`

- 源码层面的优化体现在 使用 typescript 重构了整个 vue 的源码，对冷门的功能进行了删除（filters、inline-template），并且将源码的整个结构改为了 monorepo 进行多包管理，这样的话颗粒度更细，将不同的包进行独立测试发布，可以单独引入某个包进行使用，而不用必须引入 vue
- 性能上的优化体现在响应式优化、diff 算法、模版编译优化，不过性能上的优化无法直接感知，只能是通过源码阅读去了解，真正能感知到的是语法上的优化 例如 composition API 替代 options API，可以让一块功能更加集中，无论是在阅读还是在修改方面更便捷，另外的话也解决了 mixin 逻辑复用的问题（比如说命名空间、数据来源不清晰等问题）
- 最后就是引入了 RFC，RFC 也就是听取社区的提案，通过和社区讨论某个功能及特性要修改动机原因这些
- `源码上的更新和优化`
  - Monorepo
    - vue2 源码是托管在 src 目录下，根据功能拆分出来 compiler(编译器)、core(和平台无关通用运行时代码)
    - vue3 采用 Monorepo 的形式，将模块分到了不同的包里，每个包都有各自的 API、进行类型定义以及测试。这样颗粒度更细，责任划分更加明确
  - ts 支持
    - vue 纯 js，没有类型开发，无类型系统的校验
    - vue2 是使用 flow js 进行类型系统的校验（Facebook 提出的类型系统）
    - vue3 是使用的 typescript
- `性能上的优化`

  - 代码体积缩小
    - 移除冷门功能（filter、inline-template）
    - 生产环境采用 rollup 进行构建，利用 tree-shaking 较少用户代码的体积
  - 数据劫持优化
    - vue2 Object.defineProperty
    - vue3 proxy
  - 编译优化
    1. 静态提升
    2. 预字符串化
    3. 缓存事件处理函数
    4. block tree
    5. patchFlag
  - diff 算法优化
    1. vue2 双端 diff
    2. vue3 快速 diff

- `语法 API 的优化`

  - options API
  - options API + composition API（推荐）

    - composition API 的优点
      - 查看一个功能的时候，不需要在文件上下反复横跳；并且代码风格可服用的颗粒度更细

  - 优化逻辑服用

    - mixins 缺点
      - 不清晰的数据来源
      - 命名空间的冲突
      - 隐士的跨 mixin 通信

  - vue2 是通过 new 实例化创建应用，缺点是如果一个页面存在多个 vue 应用，部分配置会影响所有的 Vue 应用（Vue.use）
  - vue3 是通过 createApp(根组件).use 互不影响

- `引入 RFC`
  - request for comments 这是一种在软件开发和开源项目中常用的提案流程，用于收集社区对某个新功能、改动或标准的意见和建议
- RFC 是一种文档格式，它详细的描述了某个特性或更改的建议，讨论其动机、设计选择、细节实现以及潜在的影响。
  在通过讨论和反馈达成共识后，RFC 会被采纳或者拒绝
- 一份 RFC 主要的组成有
  1. 标题：简单描述提案的目的
  2. 摘要：简要说明天的内容和动机
  3. 动机：解决为什么需要这个提案，解决了什么问题
  4. 详细设计: 深入描述提案的设计和实现细节
  5. 潜在的问题和代替方案: 讨论可能存在的问题和可以考虑的替代方案
  6. 不兼容的变更: 描述提案是否会引入不兼容的变更，以及变更后的影响

// 通过 RFC，vue 的核心团队能更好的听取用户建议和需求，从而开发出更符合社区的功能和特性

## 响应式上的变化

1. 拦截的变化

   > 2: 针对对象属性的读写操作进行拦截,也就是之后新增/删除的属性是监测不到的

   > 3: 针对对象的多种操作，还可以对原型的查看，函数的调用行为也能进行的拦截

2. 创建响应式数据上的变化

   > 2: 使用 data 来创建像一个男士

   > 3: 使用 ref、reactive 来创建响应式数据

   - ref: 是使用的 Object.defineProperty

   - reactive: 是使用的 proxy

3. 依赖收集上的变化

   > 2: Watcher + Dep
   > 每个响应式属性上都有一个 Dep 实例，用于做依赖收集，内部包含了一个数组，存储这个属性所有的 Watcher

   > 3: WeakMap + Map + Set
   > 依赖收集的颗粒度更细一些
   > WeakMap 键对应的是响应式对象，值是一个 Map，这个 Map 的键是改对象的属性，值是一个 Set，Set 里面存储了所有依赖于这个属性的 effect 函数

## vue2 全局构造函数带来的问题

1. 调用构造函数的静态方法会对所有 vue 应用生效，不利于不同应用之间的隔离
2. vue2 的构造函数继承了太多功能，不利于 tree-shaking
   在 vue3 中都是采用按需引入的方式来引入，充分利于 tree-shaking 来进行打包优化
3. vue2 没有把组件实例和 Vue 两个概念区分，在 vue2 中通过 new vue 创建的对象即是一个 Vue 应用，同时也是一个特殊的 vue 组件
   在 vue3 中 将两个概念给区分出来，通过 createApp 创建的对象，是一个 vue 应用，它内部提供的方法是针对中个应用的，而不是一个特殊的组件

## computed 的缓存机制，为什么不支持异步

- 缓存的是上一次 getter 计算的值
- 不支持异步的原因

> 1. 如果允许异步计算，那么在异步操作完成前 computed 无法提供有效的返回值
> 2. 数据一致性： computed 属性与 template 绑定，也就需要在渲染过程中是稳定的，如果允许异步操作，那么在渲染的时候会导致模版渲染不稳定
> 3. 调试和依赖追踪困难： 如果是异步的话，在调试和进行依赖追踪的时候会非常困难

<!-- computed 设计初衷 是用于计算并缓存一个基于响应式依赖的同步计算结果，当=依赖的响应式数据发生变化时，vue会自动计算computed的值，并将其缓存 提高性能 -->

## watch 和 computed 的区别

- ##### computed
  - 是一个计算属性，具有缓存，是同步的
- ##### watch
  - 监听数据的变化，之后执行 callback
  - 没有缓存
  - 可以执行副作用操作，发送网络请求、操作 DOM

## 组件 name 有什么作用，是否可以不写

1. 递归组件
2. 跨级组件通信
3. 通过 name 属性指定缓存的组件
4. 使用 devtools 调试时，组件名称是由 name 决定的

- 定义 name

  ```js
  // 2
  export default {
    name: 'xxx'
  }
  // 3
    1. 多写一个script标签去定义
    2. 通过defineOptions宏
  <script>
    export default {
      name: 'x'
    }
  </script>

  defineOptions({
      name: 'x'
  })

  ```

## 在项目上用了哪些性能优化

首先要确定我目前处在哪个阶段

1. 如果在编码阶段的话

- 组件拆分
- 减少没必要的响应式数据
- 组件缓存
- 使用异步加载组件
- 路由懒加载

2. 另外的话就看开发的具体项目

- 如果有长列表的场景可以使用 虚拟列表或者使用 canvas 来提升性能

3. 再一个优化就是静态资源方面的优化了

- 图片压缩
- 使用 SVG 矢量图，缩放不失真

4. 还可以在打包的时候做一些优化

- tree-shaking
- thread-loader
- CDN
- terser cssnano
- split chunks
- CDN

最后想描述一下，性能优化是为了给用户更好的体验，用户体验上给用户增加

- 骨架瓶
- 过渡动画
- 加载动画
- SSR

---

- 代码层面
  1. 组件拆分
  2. 减少没有必要的响应式数据
  3. 使用 key 优化渲染
  4. 高频事件使用防抖节流
  5. 使用 keep-alive 缓存组件
  6. 使用异步加载
  7. 路由懒加载
  8. tree-shaking、thread-loader split-chunk
  9. sourcemap 生成
- 场景优化
  1. 懒加载
  2. 虚拟滚动、常列表优化
- 静态资源优化

  1. 图片压缩
  2. 使用现代图片格式: WebP、AVIF
  3. 使用 SVG 图，矢量图，缩放不失真
  4. css js 压缩
     - terser cssnano
  5. 文件合并
  6. cdn 加速

- 用户体验优化
  - 加载动画
  - 骨架屏
  - 过渡动画
  - SSR

## 在优化前端性能会采取什么措施

1. 首先要确定是否是真的性能问题，比如一个人拿着 3g 2g 网去访问，结果反馈是打开速度慢

- 我会首先是通过 lightouse、devtools 评估页面性能
- 再一个就是通过埋点 记录用户的使用瓶颈

2. 然后就是分析问题了
   - 大文件上传 下载的问题、DOM 操作频繁等问题
   - 服务端问题： 响应速度过慢、查询慢
3. 如果是前端问题的话，确定前端具体的问题

- 网络请求过多： 减少 http 请求，合并 js css，使用 svg 图
- 静态资源过大: css、js 压缩 使用现代图片格式 比如 WebP
- 初始化资源加载过多: 按需加载 组件异步加载 懒加载
- 渲染问题: 尽可能的减少重绘和重排

- 这就是我平时解决性能问题的一个思考过程

## 路由传参的方式

- query
- state 在内存中进行传递，不会在 URL 中传递，通过 history.state 获取
- 路由 props 参数，路由定义的时候通过 props: true ，参数直接以 props 的形式传递

## Vue key 的作用

- 源代码对比在 core/vnode/patch sameVnode
- 做了什么?
  - 极大程度的复用老节点
    - 通过递归对比
- 有了 key 之后，就能明确的知道新旧 children 中节点的映射关系，知道映射关系后，就很容易判断 children 节点是否可被服用： 只要遍历新 children 中寻找是否存在具有相同 key 值的节点。

```text
  在 vue 响应式系统中，大量源码在做性能优化的事情，其中就包括 kye
  在 diff 过程中 始终尝试花费最小的代价 最大程度进行节点复用
  但使用 index 作为 key，在进行破坏顺序的操作时，因为每个节点都找不到对应的key，就会导致部分节点不能被复用，所有的 Vnode 都需要被重新创建
  而使用唯一值的话可以减少一部分的性能损耗

  此外有输入类的dom的话，会产生错误的 dom 更新，只用于列表展示的话 使用index 作为Key没有毛病
```


<Gitalk />