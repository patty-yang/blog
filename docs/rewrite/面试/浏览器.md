## 浏览器的进程模型

- `什么是进程`

  - 一个程序运行需要内存空间，(变量、对象、函数)都存在于内存中. 可以简单理解为`内存空间 就是进程`
  - 每个进程都是相互独立的，`不会影响到其他进程`(qq vx tg)
  - 进程之间通信需要同意
    ![](http://mdrs.yuanjin.tech/img/202208092057573.png)

- `什么是线程`

  - 有了进程后，有内存空间 就可以运行程序的代码了， 谁来运行代码呢 `运行代码的[人]称之为线程`
  - `一个进程至少得有一个线程`，所以在进程开启后自动创建一个线程来运行代码，该线程成为主线程
  - 如果程序需要同时执行多个代码，主线程就会启动更多的线程来执行代码，所以`一个进程中可以包含多个线程`
    ![](http://mdrs.yuanjin.tech/img/202208092108499.png)

- `浏览器是一个多进程多线程的应用程序`

  - 浏览器主进程
    - 负责界面显示，与用户交互，下载文件
  - 浏览器渲染进程

    - 负责页面渲染，解析 HTML、CSS，构建 DOM 树，计算布局，绘制页面
    - 每个 Tab 页都对应一个渲染进程
    - 渲染进程是多线程的
      - GUI 渲染线程
      - JS 引擎线程
      - 事件触发线程
      - 定时触发器线程

  - `为什么渲染线程不适合用多个线程来处理任务 - TODO`

- 处理这么多任务，主线程 `如何调度任务`

  - `js 引擎线程` 正在执行 js 函数，如果此时用户点击了按钮，那么应该先执行点击事件函数，还是先执行 js 函数呢
  - `答案: `
    - 主线程会维护一个 `任务队列`
    - 主线程会不断从 `任务队列` 中取出任务，然后执行任务
    - 主线程的执行过程就是不断重复取出任务执行任务的过程

  ` 处理方法`: `排队`

## 如何理解 js 的异步

JS 是一门单线程语言，是因为他运行在浏览器环境中，而渲染进程只有一个。

渲染进程承担着诸多工作，渲染页面，执行 js 都在其中运行，

如果使用同步的方式，就极有可能导致主线程产生阻塞，从而导致消息队列中很多任务无法得到执行

这样一来，一方面会导致繁忙的主线程白白的消耗时间，另一方面会导致页面无法及时更新，给用户造成 卡死现象
所以浏览器采用异步的方式来避免。

具体做法是当某些任务发生时，如计时器、网络、事件监听，主线程将任务交给其他线程去处理，自身立即结束任务的执行，转而执行后续代码。

当其他事情完成时，将事先传递的回调函数包装成任务，加到消息队列的末尾处排队，等待主线程调度执行
在这种异步情况下，流浪器不会阻塞，从而最大程度的保证了单线程流畅运行

## 任务优先级

。。。 没听明白 好像还是微宏任务的优先级

Promise.then setTimeout console 优先级

> 单线程是异步产生的原因
> 时间循环是异步的实现方式

<!--
- 任务没有优先级，在消息队列中先进先出，`但消息队列是有优先级的`

- 根据 W3C 的最新解释:

  - 每个任务都有一个任务类型，同一个类型的任务必须在一个队列，不同类型的任务可以分属于不同的队列。
    在一次事件循环中，浏览器可以根据实际情况从不同的队列中取出任务执行。
  - 浏览器必须准备好一个微队列，微队列中的任务优先所有其他任务执行
    https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint

> 过去把消息队列简单分为宏队列和微队列，这种说法目前已无法满足复杂的浏览器环境，取而代之的是一种更加灵活多变的处理方式。
 -->
<!--
> 面试题：阐述一下 JS 的事件循环
>
> 参考答案：
>
> 事件循环又叫做消息循环，是浏览器渲染主线程的工作方式。
>
> 在 Chrome 的源码中，它开启一个不会结束的 for 循环，每次循环从消息队列中取出第一个任务执行，而其他线程只需要在合适的时候将任务加入到队列末尾即可。
>
> 过去把消息队列简单分为宏队列和微队列，这种说法目前已无法满足复杂的浏览器环境，取而代之的是一种更加灵活多变的处理方式。
>
> 根据 W3C 官方的解释，每个任务有不同的类型，同类型的任务必须在同一个队列，不同的任务可以属于不同的队列。不同任务队列有不同的优先级，在一次事件循环中，由浏览器自行决定取哪一个队列的任务。但浏览器必须有一个微队列，微队列的任务一定具有最高的优先级，必须优先调度执行。 -->

## 垃圾回收机制

- 标记清除法

  - 如他的名字一样，有`标记`和`清除`两个阶段，在标记阶段给所有活动对象做一个标记，清除阶段则把非活动对象销毁

- 引用计数法
  - 对象有没有其他对象引用到它
  - `对象有没有其他对象引用到它`, 如果没有对象引用它，对象将会被垃圾回收机制回收。
    - 跟踪每个变量被记录的次数，
      - 当声明了一个变量并且将一个引用类型赋值给改变量的时候这个值的引用次数就为 1
    - 当该变量作为属性被包含在另一个对象中时，它的引用次数 + 1
    - 如果该变量的值被其他值覆盖了，那么 它的引用次数 - 1
    - 当这个引用次数变为 0 的时候，说明没有变量在使用它，这个对象实例就可以被垃圾回收机制回收了

<Gitalk />
