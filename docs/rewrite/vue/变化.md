## Vue3 对比 Vue2 有什么变化

我觉得可以分为大概四类

1. `源码层面的优化`
2. `性能方面的优化`
3. `API 语法方面的优化`
4. `引入了 RFC`

- 源码层面的优化体现在 使用 typescript 重构了整个 vue 的源码，对冷门的功能进行了删除（filters、inline-template），并且将源码的整个结构改为了 monorepo 进行多包管理，这样的话颗粒度更细，将不同的包进行独立测试发布，可以单独引入某个包进行使用，而不用必须引入 vue
- 性能上的优化体现在响应式优化、diff 算法、模版编译优化，不过性能上的优化无法直接感知，只能是通过源码阅读去了解，真正能感知到的是语法上的优化 例如 composition API 替代 options API，可以让一块功能更加集中，无论是在阅读还是在修改方面更便捷，另外的话也解决了 mixin 逻辑复用的问题（比如说命名空间、数据来源不清晰等问题）
- 最后就是引入了 RFC，RFC 也就是听取社区的提案，通过和社区讨论某个功能及特性要修改动机原因这些

## 响应式的变化

1. 拦截的变化

   > 2: 针对对象属性的读写操作进行拦截,也就是之后新增/删除的属性是监测不到的

   > 3: 针对对象的多种操作，还可以对原型的查看，函数的调用行为也能进行的拦截

2. 创建响应式数据上的变化

   > 2: 使用 data 来创建像一个男士

   > 3: 使用 ref、reactive 来创建响应式数据

   - ref: 是使用的 Object.defineProperty

   - reactive: 是使用的 proxy

3. 依赖收集上的变化

   > 2: Watcher + Dep
   > 每个响应式属性上都有一个 Dep 实例，用于做依赖收集，内部包含了一个数组，存储这个属性所有的 Watcher

   > 3: WeakMap + Map + Set
   > 依赖收集的颗粒度更细一些
   > WeakMap 键对应的是响应式对象，值是一个 Map，这个 Map 的键是改对象的属性，值是一个 Set，Set 里面存储了所有依赖于这个属性的 effect 函数

- vue2 中的响应式工作机制

![](vue2.png)

1. Observer: 发生在 beforeCreate 之后，created 之前，递归遍历对象的所有属性，深度完成属性的转换--`数据劫持` Object.defineProperty 来做数据劫持，生成 getter/setter
2. dep--`发布者`: 记录依赖，也就是数据和 watcher 之间的映射关系
3. `观察者`: watcher 会被发布者记录，在数据发生变化的时候，发布者会通知 watcher，watcher 收到后会交给 `scheduler`，放入时间循环的微队列中
4. 负责调度

<!-- - data 中的数据会被 vue 遍历成 getter 和 setter
- 每个组件实例都对应一个 watcher 实例，在渲染过程中把使用到的数据作为依赖，在依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染 -->

- vue3 的响应式工作机制
