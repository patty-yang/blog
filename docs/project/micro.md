# 微前端解决巨石应用

每个项目应保持 **各模块业务之间隔离 与技术栈无关、具备独立开发、独立部署和可以增量扩展迁移** 原则

## 微前端的方式

<details>
<summary>
iframe 方案
</summary>

| 问题类型     | 具体描述                                                                       |
|----------|----------------------------------------------------------------------------|
| URL 同步问题 | 浏览器刷新会导致 iframe url 丢失，前进后退功能不可用                                           |
| UI 同步问题  | DOM 结构不共享，iframe 内部弹出层无法在页面居中显示，只能局限在 iframe 内                             |
| 上下文隔离    | - 全局上下文完全隔离，内存变量不共享<br>- 系统间通信困难<br>- 主应用 cookie 需特殊处理才能实现免登<br>- 内部错误监控困难 |
| 性能问题     | 每次进入子应用都需要重建上下文、重新加载资源，影响页面加载速度                                            |

</details>

<details>
<summary>
基于 npm 集成方案
</summary>

| 优势       | 劣势               |
|----------|------------------|
| ✅ 最佳性能表现 | ❌ 版本更新需要与接入方频繁同步 |
| ✅ 良好的兼容性 | ❌ 人员变动导致的管理难度增加  |
| ✅ 组件化集成  | ❌ 维护成本高          |

</details>

💡 **传统方案的局限性**

上述两种方案虽然都是可行的微前端实现方式，但对于现代复杂的前端系统而言，这些方案显得过于简单和原始，难以满足企业级应用的需求。

🚀 **Single-SPA 的诞生**

为了解决这个问题，诞生了 Single-SPA 。作为一个专门面向微服务化的 JavaScript 框架，Single-SPA 通过定义了一套完整的应用协议，解决了微前端的技术难题。

📦 **核心协议体系**

这套协议主要包含两大核心要素：

- 🔧 主应用的配置信息
- 🔄 子应用的完整生命周期

通过这套协议，主应用能够精确地控制子应用的加载、挂载、卸载等关键生命周期，实现了微前端应用的智能调度。

⚠️ **现实中的挑战**

虽然目前市面上大量流行的微前端框架都是基于 Single-SPA 的上层封装，但如果直接将 Single-SPA 作为生产环境的技术选型，仍然存在以下局限性：

1. 🔨 仅提供基础的 API，需要进行大量的二次开发
2. 🔒 框架的侵入性较强，不利于现有项目的平滑迁移
3. 📚 使用门槛相对较高，开发体验有待提升

所以引出了很多微前端框架, 社区比较活跃的有

- qiankun(最早出现, 理念最纯粹)
- micro-app(web-component)
- wujie()

实现细节各有差异, 但总体架构基本都是使用 主应用 -> 子应用

面临的共性问题

🔄 **应用加载与切换机制**

主要包含两个核心步骤:

- 📥 获取应用 HTML 内容
- 🔍 解析并处理应用资源(script、style)，将其整合到主应用中进行渲染

## 🔒 **应用隔离**

_JS 沙箱:_

1. 快照沙箱（Snapshot Sandbox）

    - 💡 工作原理
        - 在应用挂载和卸载过程中，通过快照机制保证环境的隔离性
        - 基于 window 对象差异对比，实现环境状态的完整恢复
    - ⚙️ 具体实现

        - 激活时：保存当前 window 属性作为快照，并记录所有修改
        - 重新激活：将 window 环境还原至上次记录状态

    - 📊 优缺点分析
        - ✅ 兼容性：具有优秀的浏览器兼容性
        - ❌ 局限性：仅支持单个子应用同时运行

2. 代理沙箱（Proxy Sandbox）

    - 💡 工作原理
        - 基于 ES6 的 Proxy 特性，对 window 对象进行代理
        - 为每个子应用创建独立的代理对象，实现完全隔离
    - ⚙️ 具体实现

        - 通过 Proxy 拦截对 window 对象的访问和修改
        - 将修改存储在独立的 fakeWindow 对象中
        - 支持多实例：不同应用使用各自的代理对象

    - 📊 优缺点分析
        - ✅ 性能：无需快照，性能更优
        - ✅ 多实例：支持多个子应用同时运行
        - ❌ 兼容性：依赖 ES6 Proxy，对低版本浏览器支持不佳

_CSS 隔离:_

1. 影子 DOM（Shadow DOM）

    - 基于 HTML5 的 Shadow DOM 特性，为每个子应用创建独立的 DOM 树 - 子应用的样式只作用于其内部的 Shadow DOM 树
    - ⚠️ **实践限制**
        - 模态框（Modal）等组件通常挂载在 body 节点
        - 完全隔离可能导致组件越界
        - 主应用样式 context 丢失风险

2. CSS Module

    - 💡 工作原理
        - 基于 CSS Module 规范，为每个子应用的样式生成唯一的类名
        - 子应用的样式只作用于其内部的类名
    - ⚙️ 具体实现
        - 使用 CSS Module 规范生成唯一的类名
        - 将子应用的样式插入到主应用的样式表中

3. BEM

    - 💡 工作原理
        - 基于 BEM（Block Element Modifier）命名规范，为每个子应用的样式生成唯一的类名
        - 子应用的样式只作用于其内部的类名
    - ⚙️ 具体实现
        - 使用 BEM 命名规范生成唯一的类名
        - 将子应用的样式插入到主应用的样式表中

## 🤔 **为什么选择微前端架构?**

作为一个历经多年演变的 B 端项目,代码库变得庞大臃肿,有些地方不止用户不满意,开发者自己也不满意,体验感持续下降。所以当时公司决定对整个架构进行升级改造,不过公司的要求是
**历史代码要进行平滑的迁移,不能影响用户使用,而且若干年之后还可以使用到新的技术栈**

这个项目作为 B 端项目来说, 业务边界还是挺明确的,虽然体谅庞大,但是业务之间的耦合性不是太高,而且有些地方的技术栈都不敢轻易动弹,也是到了不得不升级的地步

最开始的时候我们也不是直接考虑的 微前端,而是 `iframe`, 但是考虑到业务需要和后续的问题,还是排除了这个方案

市面上的微前端方式都有过对比,比如 `qiankun` `wujie` `microapp` 这些 也都有各自的优缺点,最后还是使用了 qiankun

在使用的过程中也遇到了很多问题, 不过对 原理掌握的比较清楚后 这些问题也可以得到解决

当然 难的不是技术问题 而是对项目的拆分 刚开始也走了很多弯路 最后化繁为简 反而轻松不少

经过微前端的拆分后 在开发方面做到了子项目的独立开发 独立发布 在用户方面也没影响用户使用 在后期做增量开发的时候整个流程也非常顺畅