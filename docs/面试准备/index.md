随手记，随后整理

## vue 通信

- 父子组件通信

  - props
  - 传递自定义事件 emit on
  - 属性透传
  - ref 引用
  - 作用域插槽

- 跨级组件通信
  - provide inject
  - event bus 发布订阅
  - pinia

## 长列表渲染优化

1. 懒加载
   - 只有视口内的内容会被加载，其他的内容用户滚到视线内时才加载
     - **优点**
       - 节省带宽
       - 提升用户体验
     - **缺点**
       - 只能应对数据不是太多的情况。如果有几万条数据，最终会有对应数量的 DOM 结构存在于页面中，会导致页面性能降低。
2. 时间分片
   - requestAnimationFrame 由浏览器决定回掉函数的执行世纪。大量的数据分为多批次渲染，每次渲染一个片段
     - **缺点**
       - 效率低，需要多次渲染才能显示数据
       - 不直观。如果用户直接滑到最底部会等待整体渲染完成
       - 性能问题。最终也是将完整的列表项的内容给渲染出来，导致列表项非常多的时候，页面性能很低
3. 虚拟列表
   - 设置一个可视区域，在用户滚动的时候，**动态修改区域里的内容**（只渲染可视区域的项目）

## react

- 只能在最外层调用 hook，不能在循环、条件判断中使用。因为要保证每一次函数执行的时候，hook 的执行顺序
- 只能在 react 的函数组件中使用

## useCallback vs useMemo

### 共同特点

- **参数结构相同**
  - 第一个参数: 回调函数(callback)
  - 第二个参数: 依赖数组(dependencies array)
- **缓存机制**
  - 只有当依赖数组中的值发生变化时，才会重新计算
  - 有效避免不必要的重复计算
  - 优化组件性能

### 关键区别

#### useMemo

- 主要用途：缓存**计算结果**
- 返回值：回调函数的返回值
- 适用场景：
  - 复杂的计算操作
  - 需要记住计算结果的场合

#### useCallback

- 主要用途：缓存**函数本身**
- 返回值：记忆化的回调函数
- 适用场景：
  - 需要将函数作为 props 传递给子组件时
  - 防止函数组件重新渲染时不必要的函数重建
  - 优化子组件的重渲染性能

## http 请求

- 普通请求

  - 三次挥手 (打电话) -> 建立连接
  - 客户端请求
  - 服务端响应
  - 四次挥手 (client: 有事没事啊，server: 没事,client: 挂了哈，server: ok)

- 长连接
  - 三次挥手 (打电话) -> 建立连接
  - connection: keep-alive
  - 四次挥手 (client: 有事没事啊，server: 没事,client: 挂了哈，server: ok)

## https

https 保证数据在传输过程中不被窃取和篡改，从而保证传输安全

### 🔐 加密机制

#### 1. 对称加密 (Symmetric Encryption)

- 📝 **基本概念**

  - 使用同一个密钥进行加密和解密
  - 速度快，适合大量数据加密
  - 密钥管理是主要挑战

- 🔄 **工作流程**

  - 加密过程：明文 + 密钥 → 密文
  - 解密过程：密文 + 密钥 → 明文

- 🛠️ **常用算法**
  - DES (Data Encryption Standard)
    - 历史悠久，但安全性已不足
  - 3DES (Triple DES)
    - DES 的增强版，更安全但较慢
  - AES (Advanced Encryption Standard)
    - 现代标准，安全性高，性能好
  - Blowfish
    - 快速，免费，适合特定场景

#### 2. 非对称加密 (Asymmetric Encryption)

- 📝 **基本概念**

  - 使用公钥和私钥对
  - 公钥可以公开，私钥需保密
  - 计算复杂，适合小数据量加密

- 🔄 **工作流程**

  - 加密：使用公钥加密 → 只能用对应私钥解密
  - 解密：使用私钥解密 → 恢复原始信息
  - 数字签名：使用私钥签名 → 公钥验证

- 🛠️ **主流算法**
  - RSA
    - 使用最广泛的非对称加密算法
    - 基于大数分解难题
  - ECC (Elliptic Curve Cryptography)
    - 基于椭圆曲线，更高效
  - Elgamal
    - 基于离散对数问题
  - Rabin
    - 基于二次剩余问题

#### 3. 实际应用

- 🌐 **HTTPS 通信**

  - 结合使用对称和非对称加密
  - 用非对称加密传输对称密钥
  - 用对称加密传输实际数据

- 📱 **数字证书**
  - 验证身份真实性
  - 防止中间人攻击
  - 确保通信安全

<!--
(HTTP)
 (SSL)
TCP/IP) -->

<!-- ## node 生命周期 -->

## Cookie & Session

#### Cookie

**✨ 优点**

- 存储在客户端，不占用服务端资源
- 访问速度快

**⚠️ 缺点**

- 只能是字符串格式
- 存储数量有限 4kb
- 安全性较低，容易被获取、篡改、丢失

#### Session

**✨ 优点**

- 存在于服务端，安全性更高
- 支持任意格式的数据
- 存储格式理论上是无限的
- 安全性较高，不容易被获取、篡改、丢失

**⚠️ 缺点**

- 占用服务器资源
- 性能相对于 cookie 较低

## 🔐 JWT (JSON Web Token)

> 由 header.payload.signature 组成

### 1. Header (头部) 📋

- 包含令牌类型和签名算法
- 以 JSON 格式表示，通过 Base64URL 编码

```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

### 2. Payload 📦

- 存储需要传递的数据
- 同样以 JSON 格式表示
- 可包含预定义的声明和自定义声明

### 3. Signature (签名) ✍️

- 利用头部的算法对前两部分进行加密
- 确保数据不被篡改
- 验证发送者身份
- 简而言之就是 因为有这部分的存在，导致拿不到密钥，就无法伪造出签名

TODO:

- JSONP 会影响响应格式
- 只能发送 get 请求

## 🖥️ PC & 📱 Mobile 事件区别

- 🖱️ **鼠标事件**

  - `mousemove`
    - 无需按下鼠标即可触发
    - 必须保持在目标元素上
  - `mouseup`
    - 必须在目标元素上释放才能触发

- 👆 **触摸事件**
  - `touchmove`
    - 需要手指按下才能触发
    - 按下后可在元素外触发
  - `touchend`
    - 在任何位置释放都能触发

### ⏱️ 事件触发顺序

1. `touchstart`
2. `touchend`
3. `mousedown`
4. `click`
5. `mouseup`

> ⚠️ PC 事件在移动端会有约 300ms 的延迟

## 300ms

- 延迟的原因
  - 300ms 延迟是为了区分是单击还是双击
  - 双击事件触发后，会触发一次单击事件，以确保用户的意图
  - 延迟是为了防止误操作
- 解决方式
  - 禁止缩放
  - 使用移动端专属的事件

### 📱 事件穿透

#### 🔍 问题场景

当页面中存在两层重叠的元素时：

- **上层元素**: 绑定了 touch 事件，点击后消失
- **下层元素**: 具有默认点击行为的元素（如 `<a>` 或 `<form>`）

此时点击上层元素会产生以下问题：

1. 上层元素触发 touch 事件并消失
2. 300ms 后，下层元素的 click 事件也被触发

解决方案是 **阻止默认行为**。

```js
// 阻止默认行为所带来的问题
const page = document.querySelector('.page')
document.addEventListener(
  'touchstart',
  (ev) => {
    ev.preventDefault()
  },
  {
    passive: false
  }
)
```

### 1px 问题

- 原因：
  - 移动设备的屏幕像素密度不同，1px 可能对应多个物理像素
  - 移动设备的浏览器会对 1px 进行缩放，以适应不同的屏幕密度
- 解决方案：
  - 使用 js 计算 rem 基准值

### 💡 touchstart vs click

- `touchstart`：手指接触元素即触发
- `click`：需要完整的点击操作（按下+释放）才触发

## px em rem vw vh 等区别

- px
  - 基本单位，比如 1920\*1080,表示屏幕的水平方向是 1920px，垂直方向是 1080px
- em
  - 相对于父元素的字体大小,默认 16px
- rem
  - 相对于根元素的字体大小,默认 16px,1rem=16px
- vw
  - 相对于视口宽度的百分比
- vh
  - 相对于视口高度的百分比

## 微前端方案

1. 📦 iframe 存在的问题
   1. 🔗 **路由同步问题**
      1. URL 状态不同步，刷新后 iframe URL 丢失
      2. 浏览器前进后退按钮生效
   2. 🖼️ **UI 交互割裂**
      1. DOM 结构完全隔离，无法共享
      2. 弹窗、遮罩等等全局 UI 不能正常显示
   3. 🔒 **上下文隔离**
      1. 全局变量和内存不共享
      2. 跨应用通信困难
      3. 错误监控存在盲区
   4. ⚡ **性能问题**
      1. 每次加载都需要重新创建上下文
      2. 资源重复加载，影响性能
2. 📚 npm 包集成
   1. 优势
      1. 组件化集成方案
      2. 性能和组件最优
   2. 问题
      1. 版本迭代成呢高
      2. 需要手动同步更改
3. 🛠️ 主流微前端框架
   - single-spa
   - qiankun 理念纯粹，坑不少
   - micro-app 基于 web components
   - wujie
4. 🎯 Webpack5 模块联邦
   1. 优势
      1. 支持模块共享和复用
      2. 可使用外部共享模块
   2. 问题
      1. 对老项目支持度不够
      2. css/js 隔离不完善

## 微前端常见框架基础构成

- 🔒 **应用隔离**

  - JavaScript 运行环境隔离
  - CSS 样式隔离

- 📥 **加载机制**

  - HTML Entry 入口
  - 按需动态加载
  - 公共依赖管理

- 🔄 **应用通信**
  - 父子应用通信机制
  - 子应用嵌套支持
  - 并行应用管理

## 应用的加载与切换

- 📍 **路由加载**

  - qiankun 框架实现
    ![image](https://raw.githubusercontent.com/patty-yang/pic/img/test/202504081249488.png)
  - micro-app 实现
    - 基于 Web Components 技术
    - 自定义元素加载子应用

- 🔄 **渲染流程**
  - URL 解析获取子应用内容
  - 内容解析与动态渲染

## 应用的隔离与通信

#### 隔离

- 🏗️ **qiankun 沙箱方案**

- 为子应用构建独立 window 对象

- 📸 **快照沙箱**

  - 优点：兼容性好
  - 限制：单应用运行

- 🔄 **代理沙箱**

  - 基于 Proxy 实现
  - 兼容性存在限制

- 🎨 **通用隔离方案**
  - BEM 命名约定
  - CSS Modules
  - CSS-in-JS

#### 通信

- 🔗 **URL 参数传递**

  - 需要统一约定规范

- 📢 **发布订阅模式**

  - 灵活的事件通信机制

- props
