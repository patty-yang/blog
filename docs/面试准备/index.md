随手记，随后整理

## 前端框架与库的区别

> 库（Library）框架（Framework）

在前端开发领域，Vue 和 React 的核心定位是 **"构建用户界面的库"**。它们主要提供两大核心功能：

1. 基于状态的声明式渲染
2. 组件化开发模式

### 从库到框架的演进

随着前端应用的发展，单页应用（SPA）的兴起带来了新的需求：

- **路由管理**：出现了 react-router、vue-router 等解决方案
- **状态管理**：为处理日益复杂的组件状态，诞生了 Redux、React-Redux、Vuex、Pinia 等工具
- **工程化需求**：包括构建支持、数据流管理、文档工具等

要注意的是，Vue 和 React 本身并不直接提供这些功能，它们始终保持着对 UI 渲染的专注。

### 现代前端框架

当我们将"核心库 + 周边生态"组合成完整的解决方案时，这就构成了我们今天所说的"框架"。典型的例子包括：

- **UmiJS**：基于 React 的企业级框架

    - 内置路由系统
    - 完整的构建和部署支持
    - 丰富的插件生态

- **Next.js**：React 服务端框架
    - 支持服务端渲染（SSR）
    - 支持静态站点生成（SSG）
    - 完整的开发部署解决方案

## React 和 Vue 的区别：模板语法对比

在前端开发领域，React 和 Vue 采用了不同的 UI 描述方案，这体现了两个框架在设计理念上的差异。

### 两种主流的 UI 描述方案

1. 🔸 **JSX (JavaScript XML)**

   <details>
   <summary>📌 </summary>

    - React 的核心特性
    - 将 UI 描述直接融入 JavaScript 代码中

   > 💡 **JSX 的历史演进**
   >
   > JSX 最初由 React 团队创造，是一种类 XML 的 JavaScript 语法扩展。它的设计初衷源于一个重要的观察：**UI 渲染逻辑本质上与其他
   UI 逻辑存在内在耦合**。

   ```jsx
   const element = <h1>hello</>
   // react v17 之前
   const element = React.createElement('h1', null, 'hello')
   // react 17 之后
   const jsxRuntime = require('react/jsx-run-time')
   const element = jsxRuntime.jsx('h1', {children: 'hello'})
   ```

   > 🌟 **JSX 转换为虚拟 DOM 的优势**：
   >
   > 1. ⚡️ **事件处理的统一性**
        >
        >
    - 直接在 UI 声明中绑定事件处理函数
   > - 保持了代码的紧凑性和可维护性
   >
   > 1. 🔄 **动态 UI 更新的便利性**
        >
    - 通过 JavaScript 直接操作 UI 的样式和结构
   > - 实现了更灵活的组件化开发

   > React 团队选择 JSX 的核心理念是：既然 JavaScript 是前端开发的主要语言，何不让它完全接管 UI 描述的职责？这样不仅能让 UI
   和逻辑更好地协同工作，还能充分利用 JavaScript 的表达能力。

   </details>

2. **Template 模板语法**
   <details>
   <summary>📌 </summary>

    - Vue 的标志性特征
    - 更接近传统 HTML 的语法结构
      > 💡 **Template 模板语法的历史演进**
      >
      > 在早期前后端未分离的时候，流行的方案就是模版引擎，后端将数据填充到对应模版，生成 html 模版返回客户端
   </details>

**🎯 不同的设计理念与出发点**

- template
  > 📝 **从 UI 到逻辑的自然延伸**
  >
  > 使用 html 描述 UI，那么扩展 html，也就是 "从 UI 出发，扩展 UI，在 UI 中描述逻辑"
- jsx
  > 🔄 **从逻辑到 UI 的无缝集成**
  >
  > 使用 jsx 描述 UI，那么扩展 js，也就是 "从逻辑出发，扩展逻辑，在逻辑中描述 UI"

## vue 通信

- 父子组件通信

    - props
    - 传递自定义事件 emit on
    - 属性透传
    - ref 引用
    - 作用域插槽

- 跨级组件通信
    - provide inject
    - event bus 发布订阅
    - pinia

## 长列表渲染优化

1. 懒加载
    - 只有视口内的内容会被加载，其他的内容用户滚到视线内时才加载
        - **优点**
            - 节省带宽
            - 提升用户体验
        - **缺点**
            - 只能应对数据不是太多的情况。如果有几万条数据，最终会有对应数量的 DOM 结构存在于页面中，会导致页面性能降低。
2. 时间分片
    - requestAnimationFrame 由浏览器决定回掉函数的执行世纪。大量的数据分为多批次渲染，每次渲染一个片段
        - **缺点**
            - 效率低，需要多次渲染才能显示数据
            - 不直观。如果用户直接滑到最底部会等待整体渲染完成
            - 性能问题。最终也是将完整的列表项的内容给渲染出来，导致列表项非常多的时候，页面性能很低
3. 虚拟列表
    - 设置一个可视区域，在用户滚动的时候，**动态修改区域里的内容**（只渲染可视区域的项目）

## react

- 只能在最外层调用 hook，不能在循环、条件判断中使用。因为要保证每一次函数执行的时候，hook 的执行顺序
- 只能在 react 的函数组件中使用

## useCallback vs useMemo

### 共同特点

- **参数结构相同**
    - 第一个参数: 回调函数(callback)
    - 第二个参数: 依赖数组(dependencies array)
- **缓存机制**
    - 只有当依赖数组中的值发生变化时，才会重新计算
    - 有效避免不必要的重复计算
    - 优化组件性能

### 关键区别

#### useMemo

- 主要用途：缓存**计算结果**
- 返回值：回调函数的返回值
- 适用场景：
    - 复杂的计算操作
    - 需要记住计算结果的场合

#### useCallback

- 主要用途：缓存**函数本身**
- 返回值：记忆化的回调函数
- 适用场景：
    - 需要将函数作为 props 传递给子组件时
    - 防止函数组件重新渲染时不必要的函数重建
    - 优化子组件的重渲染性能

## http 请求

- 普通请求
    - 三次挥手 (打电话) -> 建立连接
    - 客户端请求
    - 服务端响应
    - 四次挥手 (client: 有事没事啊，server: 没事,client: 挂了哈，server: ok)

- 长连接
    - 三次挥手 (打电话) -> 建立连接
    - connection: keep-alive
    - 四次挥手 (client: 有事没事啊，server: 没事,client: 挂了哈，server: ok)

## https

https 保证数据在传输过程中不被窃取和篡改，从而保证传输安全

### 🔐 加密机制

#### 1. 对称加密 (Symmetric Encryption)

- 📝 **基本概念**

    - 使用同一个密钥进行加密和解密
    - 速度快，适合大量数据加密
    - 密钥管理是主要挑战

- 🔄 **工作流程**

    - 加密过程：明文 + 密钥 → 密文
    - 解密过程：密文 + 密钥 → 明文

- 🛠️ **常用算法**
    - DES (Data Encryption Standard)
        - 历史悠久，但安全性已不足
    - 3DES (Triple DES)
        - DES 的增强版，更安全但较慢
    - AES (Advanced Encryption Standard)
        - 现代标准，安全性高，性能好
    - Blowfish
        - 快速，免费，适合特定场景

#### 2. 非对称加密 (Asymmetric Encryption)

- 📝 **基本概念**

    - 使用公钥和私钥对
    - 公钥可以公开，私钥需保密
    - 计算复杂，适合小数据量加密

- 🔄 **工作流程**

    - 加密：使用公钥加密 → 只能用对应私钥解密
    - 解密：使用私钥解密 → 恢复原始信息
    - 数字签名：使用私钥签名 → 公钥验证

- 🛠️ **主流算法**
    - RSA
        - 使用最广泛的非对称加密算法
        - 基于大数分解难题
    - ECC (Elliptic Curve Cryptography)
        - 基于椭圆曲线，更高效
    - Elgamal
        - 基于离散对数问题
    - Rabin
        - 基于二次剩余问题

#### 3. 实际应用

- 🌐 **HTTPS 通信**

    - 结合使用对称和非对称加密
    - 用非对称加密传输对称密钥
    - 用对称加密传输实际数据

- 📱 **数字证书**
    - 验证身份真实性
    - 防止中间人攻击
    - 确保通信安全

<!-- 
(HTTP)
 (SSL)
TCP/IP) -->

<!-- ## node 生命周期 -->




## Cookie & Session
#### Cookie
**✨ 优点**
- 存储在客户端，不占用服务端资源
- 访问速度快

**⚠️ 缺点**
- 只能是字符串格式
- 存储数量有限 4kb
- 安全性较低，容易被获取、篡改、丢失
#### Session
**✨ 优点**
- 存在于服务端，安全性更高
- 支持任意格式的数据
- 存储格式理论上是无限的
- 安全性较高，不容易被获取、篡改、丢失

**⚠️ 缺点**
- 占用服务器资源
- 性能相对于 cookie 较低

## 🔐 JWT (JSON Web Token)
> 由 header.payload.signature 组成
### 1. Header (头部) 📋

- 包含令牌类型和签名算法
- 以 JSON 格式表示，通过 Base64URL 编码
```json
{
"alg": "HS256",
"typ": "JWT"
}
```

### 2. Payload 📦

- 存储需要传递的数据
- 同样以 JSON 格式表示
- 可包含预定义的声明和自定义声明

### 3. Signature (签名) ✍️

- 利用头部的算法对前两部分进行加密
- 确保数据不被篡改
- 验证发送者身份
- 简而言之就是 因为有这部分的存在，导致拿不到密钥，就无法伪造出签名


TODO: 
- JSONP 会影响响应格式
- 只能发送get 请求
