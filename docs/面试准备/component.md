## 前端框架与库的区别

> 库（Library）框架（Framework）

在前端开发领域，Vue 和 React 的核心定位是 **"构建用户界面的库"**。它们主要提供两大核心功能：

1. 基于状态的声明式渲染
2. 组件化开发模式

### 从库到框架的演进

随着前端应用的发展，单页应用（SPA）的兴起带来了新的需求：

- **路由管理**：出现了 react-router、vue-router 等解决方案
- **状态管理**：为处理日益复杂的组件状态，诞生了 Redux、React-Redux、Vuex、Pinia 等工具
- **工程化需求**：包括构建支持、数据流管理、文档工具等

要注意的是，Vue 和 React 本身并不直接提供这些功能，它们始终保持着对 UI 渲染的专注。

### 现代前端框架

当我们将"核心库 + 周边生态"组合成完整的解决方案时，这就构成了我们今天所说的"框架"。典型的例子包括：

- **UmiJS**：基于 React 的企业级框架

  - 内置路由系统
  - 完整的构建和部署支持
  - 丰富的插件生态

- **Next.js**：React 服务端框架
  - 支持服务端渲染（SSR）
  - 支持静态站点生成（SSG）
  - 完整的开发部署解决方案

## React 和 Vue 的区别：模板语法对比

在前端开发领域，React 和 Vue 采用了不同的 UI 描述方案，这体现了两个框架在设计理念上的差异。

### 两种主流的 UI 描述方案

1. 🔸 **JSX (JavaScript XML)**

   <details>
   <summary>📌 </summary>

   - React 的核心特性
   - 将 UI 描述直接融入 JavaScript 代码中

   > 💡 **JSX 的历史演进**
   >
   > JSX 最初由 React 团队创造，是一种类 XML 的 JavaScript 语法扩展。它的设计初衷源于一个重要的观察：**UI 渲染逻辑本质上与其他
   > UI 逻辑存在内在耦合**。

   ```jsx
   const element = <h1>hello</>
   // react v17 之前
   const element = React.createElement('h1', null, 'hello')
   // react 17 之后
   const jsxRuntime = require('react/jsx-run-time')
   const element = jsxRuntime.jsx('h1', {children: 'hello'})
   ```

   > 🌟 **JSX 转换为虚拟 DOM 的优势**：
   >
   > 1. ⚡️ **事件处理的统一性**

   - 直接在 UI 声明中绑定事件处理函数
     > - 保持了代码的紧凑性和可维护性
     >
     > 1. 🔄 **动态 UI 更新的便利性**
   - 通过 JavaScript 直接操作 UI 的样式和结构
     > - 实现了更灵活的组件化开发

   > React 团队选择 JSX 的核心理念是：既然 JavaScript 是前端开发的主要语言，何不让它完全接管 UI 描述的职责？这样不仅能让 UI
   > 和逻辑更好地协同工作，还能充分利用 JavaScript 的表达能力。

   </details>

2. **Template 模板语法**
   <details>
   <summary>📌 </summary>

   - Vue 的标志性特征
   - 更接近传统 HTML 的语法结构
     > 💡 **Template 模板语法的历史演进**
     >
     > 在早期前后端未分离的时候，流行的方案就是模版引擎，后端将数据填充到对应模版，生成 html 模版返回客户端
    </details>

**🎯 不同的设计理念与出发点**

- template
  > 📝 **从 UI 到逻辑的自然延伸**
  >
  > 使用 html 描述 UI，那么扩展 html，也就是 "从 UI 出发，扩展 UI，在 UI 中描述逻辑"
- jsx
  > 🔄 **从逻辑到 UI 的无缝集成**
  >
  > 使用 jsx 描述 UI，那么扩展 js，也就是 "从逻辑出发，扩展逻辑，在逻辑中描述 UI"

## 前端框架的分类 🎯

所有现代前端框架都建立在一个核心理念之上：**声明式渲染**。以声明的方式描述 UI，当 state 发生变化时，框架会自动完成 UI 的更新。

<!-- ### 框架的差异化策略 🔄 -->

不同框架在处理 state 变化与 UI 更新的对应关系时采用了不同的策略。随着应用复杂度的提升，state 与应用、组件和 UI 之间的关系会变得越发复杂。

<!-- 这种复杂性促使各个框架发展出独特的优化方案，以提高运行时性能。 -->
<!-- ### 三大类型划分 📊 -->

根据 state 管理和更新策略的不同，现代前端框架可以划分为三类：

1. **元素级框架** ⚛️

   - 代表：Svelte、SolidJS
   - 特点：精确到元素级别的更新控制

2. **组件级框架** 🧩

   - 代表：Vue
   - 特点：以组件为单位进行状态管理和更新

3. **应用级框架** 🏗️
   - 代表：React
   - 特点：从整体应用的角度统筹状态管理

> 💡 框架的选择应该基于项目需求、团队熟悉度以及性能要求等多个维度进行综合考虑。
