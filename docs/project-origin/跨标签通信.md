## 需求描述

在项目中有一个长表单，在一个标签页上做了操作，其他页面需要同步对应的状态。这其实就涉及到了浏览器跨标签页的通信了。

一开始是想通过 ws 实现，但是需要服务端的支撑，我们要做的仅仅是前端的支持，所以 pass 了。

然后考虑到了 localStorage，通过 onStorage 监听，最初已经通过 localStorage 实现一版了，不过这个实现还是有明显的缺陷，
我们考虑的是实时通信，但是 localStorage 最大的特定是共享数据。随着操作变多，存储的内容也越来越多了。

后来发现 sharedWorker，因为看了兼容性，所以没有过多研究

最终还是采用的 BroadCastChannel，**这个API完全和浏览器标签通信的原理契合的**，所以这就是我们的技术方案

不过具体细节在工程化环境中还是有些问题要注意的，如 vue 的 proxy 是通过 toRaw 来获取原始对象,然后才能进行传递,
**这是由于浏览器页签之间克隆数据原因引起的**

**如果要退出的话，对应的监听也需要退出，我们是封装好的一个类，是做了闭包处理，返回一个函数**

如果页面上这样的需求比较多，那么**管道的命名需要规范**，毕竟在同一个域下面，我们制定了相关的协议，来统一管道的命名

## 知识点梳理

### 原理

BroadCastChannel 原理**就是一个命名管道**, **浏览器每一个标签页本身就是一个独立的进程**，基于管道的通信，本来就是进程之间的通信方式之一。
所以这个玩意就是为 跨标签页通信而存在的

具体的API

原理是命名管道的话，所以每个 broadCastChannel 必须使用唯一一个标识符,一个页面通过 postMessage其他页面通过 message 来接受

每个浏览器标签页通常被视为一个独立的进程，而不是线程。像 chrome 就是采用的这种方式
主要是为了提高浏览器的稳定性安全性和性能。不会出现一个标签页崩溃影响到了其他的标签页。

### 浏览器页签之间克隆数据

不同的浏览器之间是通过消息传递的，**传递的消息可以是任意类型**，但是对象类型我们不能够直接赋值传递的,
因为**不同的进程中不可能存放同一个地址的数据,因此可能是做克隆传递**

但是响应式数据,如 proxy 做过代理的数据,在克隆的时候就会出现问题，不能对proxy代理的对象进行克克隆，

解决方案就是 `toRaw` 或者 展开运算符

## 跨页面通信方案

### 1. BroadcastChannel API

✨ **优点**

- 支持实时通信，可以广播给所有订阅者

❌ **局限性**

- 不支持跨域通信
- 需要现代浏览器支持

### 2. LocalStorage 事件监听

✨ **优点**

- 支持存储和共享数据

❌ **局限性**

- 不支持跨域
- 需要数据存储在本地，可能会受到安全性的影响
- 不适用实时操作，只能通过事件监听来传递数据

### 3. SharedWorker

✨ **优点**

- 支持多个标签页共享同一个后台线程，实现数据和消息的共享
- 不会占用渲染主线程

❌ **局限性**

- 不支持跨域
- 需要额外的开发工作，包括在后台线程中处理消息和同步数据
- 需要浏览器支持，兼容性比较差

### 4. window.open window.postMessage、window.opener

✨ **优点**

- 支持跨域
- 不受兼容性限制

❌ **局限性**

- 需要从当前窗口打开另一个窗口

### 5. WebSocket

✨ **优点**

- 支持实时通信，适用于需要实时数据交互的场景
- 支持跨域通信

❌ **局限性**

- 需要服务器支持 WebSocket 协议
- 可能会受到网络环境和服务器负载的影响
