## Hooks 🎣

### 解决的核心问题 🎯

- 🌀 简化复杂的生命周期管理
- 🎭 消除 this 指向困扰
- 🔄 从类组件到函数组件的优雅转变

### 编程范式转换 🚀：从**面向对象**迈向**函数式编程**。

这次转变带来了一些重要的函数式编程概念：

- 🧪 **纯函数** - 相同输入永远返回相同输出
- 🔄 **副作用** - 与外部世界交互的操作
- 🎯 **柯里化** - 将多参数函数转换为单参数函数序列
- ⚡️ **高阶函数** - 以函数为参数或返回值的函数

## 内置 Hooks 🎣

- **状态管理**

  - 🔄 **useState**: 为函数组件添加状态管理能力
  - 🎯 **useReducer**: 处理复杂的状态逻辑
  - 📦 **useContext**: 跨组件共享状态

- **副作用**

  - ⚡️ **useEffect**: 处理副作用操作
  - 🚀 **useLayoutEffect**: 同步执行副作用

- **DOM 操作**

  - 📌 **useRef**: 持久化引用值
  - 🎮 **useImperativeHandle**: 自定义暴露给父组件的实例值

- **memo**

  - 🔄 **memo**: 高阶组件，类似于 `PureComponent`
    - 💡 当 props 保持不变时，阻止组件重新渲染
    - 🔍 默认采用浅层比较策略
    - ⚙️ 支持自定义比较函数作为第二参数
    ```jsx
    const MemoComponent = memo(Component, (prevProps, nextProps) => {
      // 返回 true 则不重新渲染
      return prevProps.id === nextProps.id
    })
    ```

- 🎯 **useMemo**: 缓存计算结果

  - 💫 避免昂贵的计算在每次渲染时重复执行
  - 📊 适用于复杂数据处理或大量计算场景

- ⚡️ **useCallback**: 缓存函数引用
  - 🎭 防止函数在每次渲染时重新创建
  - 🔗 优化子组件的重渲染，尤其是配合 `memo` 使用时
  - 📦 适用于将回调函数传递给优化后的子组件
