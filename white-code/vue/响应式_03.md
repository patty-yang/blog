æ•´åˆä¸€ä¸‹ä¹‹å‰çš„ä»£ç 

```js
// handle/index.js

import reactive from '../reactive.js'
import {
  isObject,
  trackTypes,
  triggerTypes,
  hasChanged,
  RAW
} from '../utils/index.js'

import track, { resumeTracking, pauseTracking } from '../effect/track.js'
import trigger from '../effect/trigger.js'

const arrayInstrumentations = {}

;['includes', 'indexOf', 'lastIndexOf'].forEach((method) => {
  arrayInstrumentations[method] = function (...args) {
    const res = Array.prototype[method].apply(this, args)
    if (res === -1 || res === false) {
      // 2. å¦‚æœæ‰¾ä¸åˆ°ï¼Œåˆ™ä½¿ç”¨åŸå§‹å€¼ï¼Œè€Œä¸æ˜¯ä»£ç†çš„å¯¹è±¡
      return Array.prototype[method].apply(this[RAW], args)
    }
    return res
  }
})
;['push', 'poo', 'shift', 'unshift', 'splice'].forEach((method) => {
  arrayInstrumentations[method] = function (...args) {
    pauseTracking() // æš‚åœä¾èµ–æ”¶é›†
    const res = Array.prototype[method].apply(this, args)
    resumeTracking() // æ¢å¤ä¾èµ–æ”¶é›†
    return res
  }
})

function getHandler(target, key) {
  // å¢åŠ è‡ªå®šä¹‰æ ‡è¯†ï¼Œè¿”å›åŸå§‹å¯¹è±¡ é¿å…å’Œå·²æœ‰å±æ€§é‡å¤
  if (key === RAW) {
    return target
  }
  track(target, trackTypes.GET, key)

  if (arrayInstrumentations.hasOwnProperty(key) && Array.isArray(target)) {
    return arrayInstrumentations[key]
  }

  const result = Reflect.get(target, key)
  return isObject(result) ? reactive(result) : result
}

function ownKeysHandler(target) {
  track(target, trackTypes.ITERATE)
  return Reflect.ownKeys(target)
}

function setHandler(target, key, value) {
  //  ç±»å‹æ˜¯ æ–°å¢ è¿˜æ˜¯ ä¿®æ”¹
  const type = target.hasOwnProperty(key) ? triggerTypes.SET : triggerTypes.ADD
  const oldValue = target[key]

  const ordLength = Array.isArray(target) ? target.length : undefined
  const result = Reflect.set(target, key, value)

  if (hasChanged(value, oldValue)) {
    trigger(target, type, key, value)

    // åˆ¤æ–­ length æ˜¯å¦æœ‰å˜åŒ–ï¼Œå¦‚æœæœ‰å˜åŒ– æ‰‹åŠ¨å¯¹ length æ´¾å‘æ›´æ–°

    if (Array.isArray(target) && ordLength !== target.length) {
      //  length éšå¼çš„æ”¹å˜è¿˜ä¼šè§¦å‘ä¸€æ¬¡
      if (key !== 'length') {
        trigger(target, triggerTypes.SET, 'length')
      } else {
        // è¯´æ˜ length æ˜¾å¼çš„å‘ç”Ÿäº†æ”¹å˜
        for (let i = target.length; i < ordLength; i++) {
          trigger(target, triggerTypes.DELETE, i.toString())
        }
      }
    }
  }

  return result
}

function hasHandler(target, key) {
  track(target, trackTypes.HAS, key)
  return Reflect.has(target, key)
}

function deleteHandler(target, key) {
  // ä¸èƒ½æ¯æ¬¡éƒ½ç›´æ¥è§¦å‘ å…ˆåˆ¤æ–­å±æ€§æ˜¯å¦å­˜åœ¨
  const hasKey = target.hasOwnProperty(key)
  const result = Reflect.deleteProperty(target, key)
  if (hasKey) {
    trigger(target, triggerTypes.DELETE, key)
  }
  return result
}

export default {
  get: getHandler,
  ownKeys: ownKeysHandler,
  has: hasHandler,
  set: setHandler,
  deleteProperty: deleteHandler
}
```

```js
// utils/

// index.js
export { default as isObject } from './isObject.js'
export { default as hasChanged } from './hasChanged.js'
export const trackTypes = {
  GET: 'get',
  HAS: 'has',
  ITERATE: 'iterate'
}

export const triggerTypes = {
  SET: 'set',
  ADD: 'add',
  DELETE: 'delete'
}

export const RAW = Symbol('raw')

export const ITERATE_KEY = Symbol('iterate')



export default function hasChanged(value, oldValue) {
  return !Object.is(value, oldValue)
}


export default function isObject(value) {
  return typeof value === 'object' && value !== null
}

```

```js
// effect/effect.js
// ç¨å¾®æ”¹é€ ä¸€ä¸‹ å’Œ_02 å·®ä¸å¤š

export let activeEffect = null
export const targetMap = new WeakMap()

const effectStack = []

/**
 * æ‰§è¡Œä¼ å…¥çš„å‡½æ•°ï¼Œå¹¶åœ¨æ‰§è¡Œçš„è¿‡ç¨‹ä¸­å»æ”¶é›†ä¾èµ–
 * @param {Function} fn è¦æ‰§è¡Œçš„å‡½æ•°
 */
export const effect = (fn, options = {}) => {
  const { lazy = false } = options
  const environment = () => {
    try {
      activeEffect = environment
      effectStack.push(environment)

      return fn()
    } finally {
      effectStack.pop()
      activeEffect = effectStack[effectStack.length - 1] || null
    }
  }
  environment.deps = []
  environment.options = options
  if (!lazy) {
    environment()
  }
  return environment
}

export const cleanup = (environment) => {
  const deps = environment.deps // æ‹¿åˆ°å½“å‰ç¯å¢ƒçš„ä¾èµ–
  if (deps.length) {
    deps.forEach((dep) => dep.delete(environment))
    deps.length = 0
  }
}
```

effect çš„æ‰§è¡Œæ˜¯ç°åœ¨ track æ”¶é›†å®Œä¾èµ–å æ”¹é€  track.js

```js
// track.js
import { targetMap, activeEffect } from './effect.js'
import { trackTypes, ITERATE_KEY } from '../utils/index.js'
// æ˜¯å¦éœ€è¦æ”¶é›†ä¾èµ–
let shouldTrack = true

/**
 * æš‚åœä¾èµ–æ”¶é›†
 */
export function pauseTracking() {
  shouldTrack = false
}

/**
 *  æ¢å¤ä¾èµ–æ”¶é›†
 */
export function resumeTracking() {
  shouldTrack = true
}

function track(target, type, key) {
  if (!shouldTrack || !activeEffect) return false

  // ä¸€å±‚ä¸€å±‚çš„å»æ‰¾ï¼Œæ‰¾åˆ°äº†å°±å­˜å‚¨
  let propertyMap = targetMap.get(target)
  if (!propertyMap || !activeEffect) {
    targetMap.set(target, (propertyMap = new Map()))
  }

  // å¦‚æœæ˜¯éå†æ‰€æœ‰å±æ€§ï¼Œkey ä¼šæ˜¯ä¸€ä¸ª undefined
  if (type === trackTypes.ITERATE) {
    key = ITERATE_KEY
  }

  let typeMap = propertyMap.get(key)
  if (!typeMap) {
    propertyMap.set(key, (typeMap = new Map()))
  }

  // æ ¹æ® type å€¼ æ‰¾å¯¹åº”çš„ set
  let depSet = typeMap.get(type)
  if (!depSet) {
    typeMap.set(type, (depSet = new Set()))
  }

  // å¦‚æœå½“å‰çš„ activeEffect æ²¡æœ‰è¢«æ”¶é›†è¿‡ï¼Œåˆ™æ”¶é›†
  if (!depSet.has(activeEffect)) {
    depSet.add(activeEffect)
    activeEffect.deps.push(depSet)
  }
}

export default track
```

```js
// trigger.js
import { triggerTypes, trackTypes, ITERATE_KEY } from '../utils/index.js'
import { activeEffect, targetMap } from './effect.js'

const triggerTypeMap = {
  [triggerTypes.SET]: [trackTypes.GET],
  [triggerTypes.ADD]: [trackTypes.GET, trackTypes.HAS, trackTypes.ITERATE],
  [triggerTypes.DELETE]: [trackTypes.GET, trackTypes.HAS, trackTypes.ITERATE]
}

function trigger(target, type, key, value) {
  // æ‰¾åˆ°å¯¹åº”çš„ä¾èµ–ï¼Œç„¶åæ‰§è¡Œ
  const effectFns = getEffectFns(target, type, key)
  if (!effectFns) return
  for (const effectFn of effectFns) {
    if (activeEffect === effectFn) {
      continue
    }
    // è¯´æ˜ä¼ å…¥äº† schedulerï¼Œè‡ªå·±æ¥å¤„ç†ä¾èµ–çš„å‡½æ•°
    if (effectFn?.options?.scheduler) {
      effectFn.options.scheduler(effectFn)
    } else {
      effectFn()
    }
  }
}

/**
 * æ‰¾åˆ°å¯¹åº”çš„ä¾èµ–é›†åˆ
 * @param {*} target
 * @param {*} type
 * @param {*} key
 * @returns
 */
const getEffectFns = (target, type, key) => {
  const propertyMap = targetMap.get(target)
  if (!propertyMap) return

  // å¦‚æœæ˜¯æ–°å¢æˆ–è€…åˆ é™¤ï¼Œä¼šé¢å¤–è§¦å‘è¿­ä»£
  const keys = [key]
  if (type === triggerTypes.ADD || type === triggerTypes.DELETE) {
    keys.push(ITERATE_KEY)
  }

  const effectFns = new Set() // å­˜å‚¨ä¾èµ–çš„å‡½æ•°

  for (const key of keys) {
    const typeMap = propertyMap.get(key)
    if (!typeMap) {
      continue
    }
    const trackTypes = triggerTypeMap[type]
    for (const trackType of trackTypes) {
      const dep = typeMap.get(trackType)
      if (!dep) {
        continue
      }
      dep.forEach((effectFn) => effectFns.add(effectFn))
    }
  }

  return effectFns
}

export default trigger
```

æ˜¯ä»€ä¹ˆæ„æ€æ æ¥ä¸€å¼ å›¾

![image](../../images/effect/dependence.png)

- targetMap å­˜æ”¾çš„æ˜¯å±æ€§ä¹‹é—´çš„æ˜ å°„å…³ç³»
- propMap æ˜¯å¯¹è±¡ä¸‹å±æ€§çš„ä¸€ä¸ªæ˜ å°„å…³ç³»ï¼Œæœ‰ä¸ªç‰¹æ®Šçš„å±æ€§ï¼ˆITERï¼‰ æ˜¯åœ¨éå†çš„æ—¶å€™
- typeMap æ˜¯æ“ä½œç±»å‹çš„ä¸€ä¸ª mapï¼Œé’ˆå¯¹å±æ€§çš„æ“ä½œè¡Œä¸º
- depSet å­˜æ”¾çš„æ˜¯ä¾èµ–å‡½æ•°

track å®ç°çš„æ˜¯ä»€ä¹ˆå‘¢ã€‚

å°±æ˜¯æ ¹æ®ç»“æ„ä¸€å±‚ä¸€å±‚å»å¯»æ‰¾ ç„¶åå­˜å‚¨

## lazy

æ‡’æ‰§è¡Œï¼Œä¸æœŸæœ›è‡ªåŠ¨å»æ”¶é›†ä¾èµ–

```js
// effect.js
if (!lazy) {
  environment()
}
```

## scheduler

æ˜¯å¦éœ€è¦è¿›è¡Œæ´¾å‘æ›´æ–° æ‰‹åŠ¨æ§åˆ¶

```js
const obj = {
  a: 1,
  b: 2
}

const state = reactive(obj)

let isRun = false
const fn = () => {
  console.log('ğŸš€ ~ fn ~ fn:')
  state.a = state.a + 1
}
// è¿™æ ·çš„è¯å°±åªä¼šæ‰§è¡Œä¸¤æ¬¡
const effectFn = effect(fn, {
  lazy: true,
  scheduler: (fn) => {
    Promise.resolve().then(() => {
      if (!isRun) {
        isRun = true
        fn()
      }
    })
  }
})

effectFn()

state.a++
state.a++
state.a++
state.a++
state.a++
```
